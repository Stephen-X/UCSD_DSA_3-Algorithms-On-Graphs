import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Acyclicity {
    private static boolean[] visited;  // vertices that have been thoroughly checked
    private static boolean[] isOnStack;  // is vertex on the stack for current recursion call?
    private static boolean hasCycle;  // does at least one cycle exist?

    // explore using DFS
    private static void explore(List<Integer>[] adj, int v) {
        visited[v] = true;
        isOnStack[v] = true;
        for (int p : adj[v]) {
            if (!visited[p]) {
                explore(adj, p);
            } else if (isOnStack[p]) { // this vertex has been accessed once in this path; cycle found
                hasCycle = true;
                break;
            }
        }
        isOnStack[v] = false;  // re-initialize for the next recursion call
    }

    private static int acyclic(List<Integer>[] adj) {
        visited = new boolean[adj.length];
        isOnStack = new boolean[adj.length];
        for (int i = 0; i < adj.length; i++) {
            explore(adj, i);
            if (hasCycle) return 1;  // at least one cycle found
        }
        return 0;
    }

    @SuppressWarnings({"unchecked", "rawtypes"}) // supress warnings generated by generic array
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();  // number of vertices
        int m = scanner.nextInt();  // number of edges
        List<Integer>[] adj = (ArrayList<Integer>[])new ArrayList[n];
        for (int i = 0; i < n; i++) {
            adj[i] = new ArrayList<Integer>();
        }
        for (int i = 0; i < m; i++) {
            int x, y;
            x = scanner.nextInt();
            y = scanner.nextInt();
            adj[x - 1].add(y - 1);
        }
        System.out.println(acyclic(adj));
    }
}

